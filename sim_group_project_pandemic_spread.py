# -*- coding: utf-8 -*-
"""Sim Group Project Pandemic Spread.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-XoflJs6qg84NDGb5ZEhXNPmMTtmGfBa

# Library Imports
"""

pip install distfit

# import libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from collections import Counter
from distfit import distfit
import statistics as sts

"""Exploring Binomial Data Generation"""

# explore the binomial data generation
np.random.seed(123)
first_list = []
for i in range(100000):
  successes = np.random.binomial(1, 0.02, 30)
  first_list.append(sum(successes))

counts = Counter(first_list)

sorted_counts = counts.most_common()

# Print counts and values
for value, count in sorted_counts:
    print(f"Value: {value}, Count: {count}")

# method 2 for exploring binomial data generation
np.random.seed(999999999)
second_list = np.random.binomial(30, 0.02, 100000)

counts = Counter(second_list)

sorted_counts = counts.most_common()

# Print counts and values
for value, count in sorted_counts:
    print(f"Value: {value}, Count: {count}")

"""# Base Case Simulation"""

'''
For the first case where there is a 0 percent chance of someone being immunized beforehand
1) Define a simulation
2) run the simulation n times

keep track of for future updates:
1) newly infected: 3 days later we need to remove that number from total infected by updating number cured
2)
'''

# define the simulation
def simulate_pandemic(seed):

  # set initial values and params, edit as needed
  total_students = 31
  p_infected = 0.02
  num_infected_start = [1]
  num_infected_new = []
  num_no_longer_infected_new = [0, 0]
  total_num_no_longer_infected = [0, 0]
  day = 0
  days_infected = 3
  can_get_reinfected = False
  probably_immunized = False
  can_get_infected = True
  num_possible_to_infect = [total_students - num_infected_start[0]]


  # end when no one can be infected
  while num_infected_start[-1] != 0:

    day += 1
    # print(day)

    # update the seed
    seed += day
    np.random.seed(seed)



    # how many are infected to begin with today
    if day > 1:
      num_infected_start.append(num_infected_start[day - 2] + num_infected_new[day - 2] - num_no_longer_infected_new[day - 2])
      # print('num_infected_start')
      # print(num_infected_start)

      # determine who we can infect
      num_possible_to_infect.append(total_students - num_infected_start[day - 1] - total_num_no_longer_infected[day - 2])
      # print('num_possible_to_infect')
      # print(num_possible_to_infect)


    # run this portion during the weekdays
    if 1 <= day % 7 <= 5:

      # infect some new students, muahahahaha
      if num_infected_start[day - 1] < 0:
        print('num_infected_start')
        print(num_infected_start)
        print('num_possible_to_infect')
        print(num_possible_to_infect)
        print('num_infected_new')
        print(num_infected_new)
        print('num_no_longer_infected_new')
        print(num_no_longer_infected_new)
        print('total_num_no_longer_infected')
        print(total_num_no_longer_infected)

      if num_possible_to_infect[day - 1] < 0:
        print('num_infected_start')
        print(num_infected_start)
        print('num_possible_to_infect')
        print(num_possible_to_infect)
        print('num_infected_new')
        print(num_infected_new)
        print('num_no_longer_infected_new')
        print(num_no_longer_infected_new)
        print('total_num_no_longer_infected')
        print(total_num_no_longer_infected)

        print(seed)

      new_infected = np.sum(np.random.binomial(num_infected_start[day - 1], p_infected, num_possible_to_infect[day - 1]) == 1)
      num_infected_new.append(new_infected)
      # print('num_infected_new')
      # print(num_infected_new)


    # run this portion during the weekends
    else:
      num_infected_new.append(0)
      # print('num_infected_new')
      # print(num_infected_new)

    # determine the number no longer infected and update the totals
    if day > 2:
      if day == 3:
        num_no_longer_infected_new.append(num_infected_start[day - 3])
      else:
        num_no_longer_infected_new.append(num_infected_new[day - 4])

      # print('num_no_longer_infected_new')
      # print(num_no_longer_infected_new)

      total_num_no_longer_infected.append(total_num_no_longer_infected[day - 2] + num_no_longer_infected_new[day - 1])
      # print('total_num_no_longer_infected')
      # print(total_num_no_longer_infected)


  return day - 1, num_infected_start, num_infected_new

# single run of the above function
simulate_pandemic(5555)

# run the simulation n times and return outcome
from matplotlib import pyplot as plt


n = 100000
pandemic_length = []
second_day_list = []
first_day_list = []
second_day_total = []
infected_totals = []


for i in range(n):
  seed = i+1234567+1
  run_i = simulate_pandemic(seed)

  pandemic_length.append(run_i[0])
  second_day_list.append(run_i[2][1])
  first_day_list.append(run_i[2][0])
  second_day_total.append(run_i[1][2])
  infected_totals.append(run_i[1])

# first day expected number newly infected

plt.hist(first_day_list)

# plt.hist(second_day_total)
plt.xlabel('Number of Students Infected')
plt.ylabel('Count')
plt.title('Total Students Infected on Day 1')

counts_day_2_end = Counter(second_day_total)

counts_day_1 = Counter(first_day_list)


print(round(sts.mean(map(float, first_day_list)),2))
print(counts_day_1)

# second day expected number newly infected

#plt.hist(second_day_list)

plt.hist(second_day_total)
plt.xlabel('Number of Students')
plt.ylabel('Count')
plt.title('Total Students Infected on Day 2')
counts_day_2_end = Counter(second_day_total)

counts_day_2 = Counter(second_day_list)


print(round(sts.mean(map(float, second_day_list)),2))
print(counts_day_2)

# total infected day 2 (start of day 3)

plt.hist(second_day_total)
plt.xlabel('Number of Students')
plt.ylabel('Count')
plt.title('Total Students Infected on Day 2')
counts_day_2_end = Counter(second_day_total)


print(round(sts.mean(map(float, second_day_total)),2))
print(counts_day_2_end)

# expected length of the pandemic: 3 days means Timmy infected no one and was himself cured after 3 days

pand_len = round(np.average(pandemic_length),1)

print('The average length of the pandemic without immunizations is:',pand_len)

plt.hist(pandemic_length)

counts = Counter(pandemic_length)

sorted_counts = counts.most_common(100)

# Print counts and values
for value, count in sorted_counts:
   print(f"Value: {value}, Count: {count}")

plt.xlabel('Day of Pandemic End')
plt.ylabel('Count')
plt.title('School Day of Pandemic End')

# define function to find longest sublist in list of lists



def FindMaxLength(lst):
    maxList = max(lst, key=len)
    maxLength = len(maxList)

    return maxList, maxLength

longest_list = FindMaxLength(infected_totals)

long_len = longest_list[1]

print(longest_list)

# fill in 0s for all sublists to reach the length of the longest sublist

for row in infected_totals:
    while len(row) < long_len:
        row.append(0)

print(infected_totals[:3])

# create list of expected infected on a given day, remember that first index value is day 0

df = pd.DataFrame(infected_totals)

# df.head()

expected_number_infected = df.mean()

print(expected_number_infected)

plt.plot(expected_number_infected)

plt.xlabel('School Day')
plt.ylabel('Average Number of Students Infected')
plt.title('Average Number of Students Infected by School Day')

# Display the plot
plt.show()



# distfit for 1st case
dfit = distfit()

results = dfit.fit_transform(np.array(pandemic_length), verbose = 1)

# Plot summary
dfit.plot_summary()

# PDF plot
dfit.plot()

# Plot PDF
fig, ax = dfit.plot(chart='pdf')

# Add the CDF to the plot
fig, ax = dfit.plot(chart='cdf', n_top=1, ax=ax)

# QQ-plot for top 10 fitted distributions
fig, ax = dfit.qqplot(np.array(pandemic_length), n_top=10)

"""# Case 2 Simulation (immunized case)"""

'''
For the second case where there is a 50 percent chance of someone being immunized beforehand
1) Define a simulation
2) run the simulation n times

keep track of for future updates:
1) newly infected: 3 days later we need to remove that number from total infected by updating number cured
2)
'''

# define the simulation
def simulate_pandemic_immunized(seed):

  # set initial values and params, edit as needed
  total_students = 31
  p_infected = 0.02
  num_infected_start = [1]
  num_infected_new = []
  day = 0
  days_infected = 3
  can_get_reinfected = False
  probability_immunized = 0.5
  can_get_infected = True


  # determine the number of people who are immunized
  num_immunized = np.random.binomial(total_students - num_infected_start[day], probability_immunized)

  num_no_longer_infected_new = [0, 0]
  total_num_no_longer_infected = [num_immunized, num_immunized]
  num_possible_to_infect = [total_students - num_infected_start[day] - num_immunized]


  # end when no one can be infected
  while num_infected_start[-1] != 0:

    day += 1
    # print(day)

    # update the seed
    seed += day
    np.random.seed(seed)



    # how many are infected to begin with today
    if day > 1:
      num_infected_start.append(num_infected_start[day - 2] + num_infected_new[day - 2] - num_no_longer_infected_new[day - 2])
      # print('num_infected_start')
      # print(num_infected_start)

      # determine who we can infect
      num_possible_to_infect.append(total_students - num_infected_start[day - 1] - total_num_no_longer_infected[day - 2])
      # print('num_possible_to_infect')
      # print(num_possible_to_infect)


    # run this portion during the weekdays
    if 1 <= day % 7 <= 5:

      # infect some new students, muahahahaha
      new_infected = np.sum(np.random.binomial(num_infected_start[day - 1], p_infected, num_possible_to_infect[day - 1]) == 1)
      num_infected_new.append(new_infected)
      # print('num_infected_new')
      # print(num_infected_new)


    # run this portion during the weekends
    else:
      num_infected_new.append(0)
      # print('num_infected_new')
      # print(num_infected_new)

    # determine the number no longer infected and update the totals
    if day > 2:
      if day == 3:
        num_no_longer_infected_new.append(num_infected_start[day - 3])
      else:
        num_no_longer_infected_new.append(num_infected_new[day - 4])

      # print('num_no_longer_infected_new')
      # print(num_no_longer_infected_new)

      total_num_no_longer_infected.append(total_num_no_longer_infected[day - 2] + num_no_longer_infected_new[day - 1])
      # print('total_num_no_longer_infected')
      # print(total_num_no_longer_infected)


  return day - 1, num_infected_start, num_infected_new,num_immunized

# run a bunch of times
n = 100000
pandemic_length = []
second_day_list = []
first_day_list = []
second_day_total = []
infected_totals = []
num_immunized_ls = []

for i in range(n):
  seed = i+123456789+1
  run_i = simulate_pandemic_immunized(seed)
  pandemic_length.append(run_i[0])
  second_day_list.append(run_i[2][1])
  first_day_list.append(run_i[2][0])
  second_day_total.append(run_i[1][2])
  infected_totals.append(run_i[1])
  num_immunized_ls.append(run_i[3])

# plot number immunized

plt.hist(num_immunized_ls)
plt.title('Histogram of Number of Students Immunized')
plt.ylabel('Count')
plt.xlabel('Number of Students Immunized')

# first day expected number newly infected

plt.hist(first_day_list)
plt.title('Histogram of Number of Students Infected on Day 1')
plt.ylabel('Count')
plt.xlabel('Number of Students Infected')
counts_day_1 = Counter(first_day_list)

print(round(sts.mean(map(float, first_day_list)),2))
print(counts_day_1)

# second day expected number newly infected

plt.hist(second_day_list)

counts_day_2 = Counter(second_day_list)

print(round(sts.mean(map(float, second_day_list)),2))
print(counts_day_2)

# total infected day 2 (start of day 3)

plt.hist(second_day_total)
plt.title('Total Students infected after Day 2')
plt.ylabel('Count')
plt.xlabel('Number of Students Infected')

counts_day_2_end = Counter(second_day_total)

print(round(sts.mean(map(float, second_day_total)),2))
print(counts_day_2_end)

# pandemic length distribution. 3 means no one was infected on days 1, 2, or 3 and Timmy was cured by end of day 3.

plt.hist(pandemic_length)
plt.title('Histogram of Pandemic Length')
plt.ylabel('Count')
plt.xlabel('Number of Students Infected')

average_pandemic_length = np.average(pandemic_length)

print('The average pandemic length with immunizations is:', average_pandemic_length)

counts = Counter(pandemic_length)

sorted_counts = counts.most_common(100)

# Print counts and values
for value, count in sorted_counts:
   print(f"Value: {value}, Count: {count}")

# get longest sublist

longest_list = FindMaxLength(infected_totals)
long_len = longest_list[1]
print(longest_list)

# fill in 0s for all sublists to reach the length of the longest sublist

for row in infected_totals:
    while len(row) < long_len:
        row.append(0)

print(infected_totals[:3])

df2 = pd.DataFrame(infected_totals)

# df.head()

expected_number_infected = df2.mean()

print(expected_number_infected)

plt.plot(expected_number_infected)
plt.title('Average Number of Infected Students by School Day')
plt.ylabel('Number of Students Infected')
plt.xlabel('School Day')



# distfit for 2nd case
dfit = distfit()

results = dfit.fit_transform(np.array(pandemic_length), verbose = 1)

# Plot summary
dfit.plot_summary()

# PDF plot
dfit.plot()

# Plot PDF
fig, ax = dfit.plot(chart='pdf')

# Add the CDF to the plot
fig, ax = dfit.plot(chart='cdf', n_top=1, ax=ax)

# QQ-plot for top 10 fitted distributions
fig, ax = dfit.qqplot(np.array(pandemic_length), n_top=10)

"""# Simulating Multiple *p* values in the base case"""

'''
Base case - this time with multiple p values
'''

# define the simulation
def simulate_pandemic(seed,p_infected=0.02):

  # set initial values and params, edit as needed
  total_students = 31
  num_infected_start = [1]
  num_infected_new = []
  num_no_longer_infected_new = [0, 0]
  total_num_no_longer_infected = [0, 0]
  day = 0
  days_infected = 3
  can_get_reinfected = False
  probably_immunized = False
  can_get_infected = True
  num_possible_to_infect = [total_students - num_infected_start[0]]


  # end when no one can be infected
  while num_infected_start[-1] != 0:

    day += 1
    # print(day)

    # update the seed
    seed += day
    np.random.seed(seed)



    # how many are infected to begin with today
    if day > 1:
      num_infected_start.append(num_infected_start[day - 2] + num_infected_new[day - 2] - num_no_longer_infected_new[day - 2])
      # print('num_infected_start')
      # print(num_infected_start)

      # determine who we can infect
      num_possible_to_infect.append(total_students - num_infected_start[day - 1] - total_num_no_longer_infected[day - 2])
      # print('num_possible_to_infect')
      # print(num_possible_to_infect)


    # run this portion during the weekdays
    if 1 <= day % 7 <= 5:

      # infect some new students, muahahahaha
      if num_infected_start[day - 1] < 0:
        print('num_infected_start')
        print(num_infected_start)
        print('num_possible_to_infect')
        print(num_possible_to_infect)
        print('num_infected_new')
        print(num_infected_new)
        print('num_no_longer_infected_new')
        print(num_no_longer_infected_new)
        print('total_num_no_longer_infected')
        print(total_num_no_longer_infected)

      if num_possible_to_infect[day - 1] < 0:
        print('num_infected_start')
        print(num_infected_start)
        print('num_possible_to_infect')
        print(num_possible_to_infect)
        print('num_infected_new')
        print(num_infected_new)
        print('num_no_longer_infected_new')
        print(num_no_longer_infected_new)
        print('total_num_no_longer_infected')
        print(total_num_no_longer_infected)

        print(seed)

      new_infected = np.sum(np.random.binomial(num_infected_start[day - 1], p_infected, num_possible_to_infect[day - 1]) == 1)
      num_infected_new.append(new_infected)
      # print('num_infected_new')
      # print(num_infected_new)


    # run this portion during the weekends
    else:
      num_infected_new.append(0)
      # print('num_infected_new')
      # print(num_infected_new)

    # determine the number no longer infected and update the totals
    if day > 2:
      if day == 3:
        num_no_longer_infected_new.append(num_infected_start[day - 3])
      else:
        num_no_longer_infected_new.append(num_infected_new[day - 4])

      # print('num_no_longer_infected_new')
      # print(num_no_longer_infected_new)

      total_num_no_longer_infected.append(total_num_no_longer_infected[day - 2] + num_no_longer_infected_new[day - 1])
      # print('total_num_no_longer_infected')
      # print(total_num_no_longer_infected)


  return day - 1, num_infected_start, num_infected_new

n = 10000
pandemic_lengths = []
different_ps = np.arange(0.01, 0.41, 0.01)
different_ps = np.round(different_ps,2)
data_per_p = {p: [] for p in different_ps}

# Simulating pandemics for different values of p
for p_infected in different_ps:
    for i in range(n):
        seed = i + 123456789 + 1
        run_i = simulate_pandemic(seed, p_infected=p_infected)
        data_per_p[p_infected].append(run_i[0])

# avg lengths
average_lengths = [np.average(data_per_p[p]) for p in different_ps]

# Plotting bar chart with rotated x-axis labels
plt.figure(figsize=(15, 6))
plt.bar(np.arange(len(different_ps)), average_lengths, alpha=0.7)
plt.xlabel('p')
plt.ylabel('Average Pandemic Length')
plt.title('Average Pandemic Length for Different p Values')
plt.xticks(np.arange(len(different_ps)), [f"{p}" for p in different_ps], rotation=90)  # Rotate x-axis labels
plt.grid(True)

plt.show()

"""# General Function: Gives User Ability to Simulate a Disease spread based on several input factors"""

'''
This function can be applied to any disease - as long as you know the class size,immunization rate,class size, and days infected
(you can simulate multiple values for each)
'''

# define the simulation
def simulate_pandemic_immunized(seed,p_infected = 0.02, total_students=31,probability_immunized=0.5,days_infected=3):

  # set initial values and params, edit as needed
  num_infected_start = [1]
  num_infected_new = []
  day = 0
  can_get_reinfected = False
  can_get_infected = True


  # determine the number of people who are immunized
  num_immunized = np.random.binomial(total_students - num_infected_start[day], probability_immunized)

  num_no_longer_infected_new = [0, 0]
  total_num_no_longer_infected = [num_immunized, num_immunized]
  num_possible_to_infect = [total_students - num_infected_start[day] - num_immunized]


  # end when no one can be infected
  while num_infected_start[-1] != 0:

    day += 1
    # print(day)

    # update the seed
    seed += day
    np.random.seed(seed)



    # how many are infected to begin with today
    if day > 1:
      num_infected_start.append(num_infected_start[day - 2] + num_infected_new[day - 2] - num_no_longer_infected_new[day - 2])
      # print('num_infected_start')
      # print(num_infected_start)

      # determine who we can infect
      num_possible_to_infect.append(total_students - num_infected_start[day - 1] - total_num_no_longer_infected[day - 2])
      # print('num_possible_to_infect')
      # print(num_possible_to_infect)


    # run this portion during the weekdays
    if 1 <= day % 7 <= 5:

      # infect some new students, muahahahaha
      new_infected = np.sum(np.random.binomial(num_infected_start[day - 1], p_infected, num_possible_to_infect[day - 1]) == 1)
      num_infected_new.append(new_infected)
      # print('num_infected_new')
      # print(num_infected_new)


    # run this portion during the weekends
    else:
      num_infected_new.append(0)
      # print('num_infected_new')
      # print(num_infected_new)

    # determine the number no longer infected and update the totals
    if day > 2:
      if day == 3:
        num_no_longer_infected_new.append(num_infected_start[day - 3])
      else:
        num_no_longer_infected_new.append(num_infected_new[day - 4])

      # print('num_no_longer_infected_new')
      # print(num_no_longer_infected_new)

      total_num_no_longer_infected.append(total_num_no_longer_infected[day - 2] + num_no_longer_infected_new[day - 1])
      # print('total_num_no_longer_infected')
      # print(total_num_no_longer_infected)


  return day - 1, num_infected_start, num_infected_new,num_immunized

n = 1000
pandemic_lengths = []
different_ps = np.arange(0.01, 0.51, 0.01)
different_ps = np.round(different_ps,2)
data_per_p = {p: [] for p in different_ps}

# Simulating pandemics for different values of p
for p_infected in different_ps:
    for i in range(n):
        seed = i + 123456789 + 1
        run_i = simulate_pandemic_immunized(seed,p_infected = p_infected, total_students=60,probability_immunized=0.3,days_infected=5)
        data_per_p[p_infected].append(run_i[0])

# avg lengths
average_lengths = [np.average(data_per_p[p]) for p in different_ps]

# Plotting bar chart with rotated x-axis labels
plt.figure(figsize=(15, 6))
plt.bar(np.arange(len(different_ps)), average_lengths, alpha=0.7)
plt.xlabel('p')
plt.ylabel('Average Pandemic Length')
plt.title('Average Pandemic Length for Different p Values')
plt.xticks(np.arange(len(different_ps)), [f"{p}" for p in different_ps], rotation=90)  # Rotate x-axis labels
plt.grid(True)

plt.show()

# run a bunch of times
n = 100000
pandemic_length = []
second_day_list = []
first_day_list = []
second_day_total = []
infected_totals = []
num_immunized_ls = []

for i in range(n):
  seed = i+123456789+1
  run_i = simulate_pandemic_immunized(seed,p_infected = 0.04, total_students=200,probability_immunized=0.07,days_infected=4)
  pandemic_length.append(run_i[0])
  second_day_list.append(run_i[2][1])
  first_day_list.append(run_i[2][0])
  second_day_total.append(run_i[1][2])
  infected_totals.append(run_i[1])
  num_immunized_ls.append(run_i[3])

# get longest sublist

longest_list = FindMaxLength(infected_totals)
long_len = longest_list[1]

# create list of expected infected on a given day, remember that first index value is day 0
# fill in 0s for all sublists to reach the length of the longest sublist

for row in infected_totals:
    while len(row) < long_len:
        row.append(0)

print(infected_totals[:3])
df2 = pd.DataFrame(infected_totals)

# df.head()

expected_number_infected = df2.mean()

print(expected_number_infected)

plt.plot(expected_number_infected)
plt.title('Average Number of Infected Students by School Day')
plt.ylabel('Number of Students Infected')
plt.xlabel('School Day')

